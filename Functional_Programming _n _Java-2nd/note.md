todo : 선언적 스타일의 한 예입니다
변경 가능한 변수를 가지고 엉뚱한 짓을 하지 마세요
후드 아래에 포장된 반복 단계
덜 복잡하다
더 나은 명확성; 집중력을 유지합니다
임피던스 감소, 코드는 비즈니스 의도를 밀접하게 따라갑니다.

오류가 덜 발생함
이해하고 유지 관리하기 더 쉽습니다.

## 단순한 경우를 넘어서

List.stream().filter(f->f>0).map(m->m.toTransformer).sum();

깔끔하게 구성되어 있고 복잡하지 않음
저수준 작업이 없음
논리를 강화하거나 변경하는 것이 더 쉽습니다.
메서드 라이브러리에 의해 제어되는 반복
효율적; 루프의 지연 평가
원하는 곳에서 병렬화가 더 쉽습니다.



우리는 변수의 명시적 변형이나 재할당을 피했습니다. 이는 종종 버그의 원인이 되고 동시성을 만들기 어려운 코드를 생성합니다. 명령형 버전에서는 반복해서 루프 내에서 totalOfDiscountedPrices 변수를 설정합니다. 함수형 스타일 버전에서는 코드에 명시적 변형이 없습니다. 변형이 적을수록 코드 오류가 줄어듭니다

함수형 버전은 쉽게 병렬화할 수 있습니다. 계산에 시간이 많이 걸리는 경우 목록의 각 요소에 대해 동시에 쉽게 실행할 수 있습니다. 명령형 버전을 병렬화하면 totalOfDiscountedPrices 변수의 동시 수정에 대해 걱정해야 합니다. 함수형 버전에서는 변수가 완전히 구워진 후에만 변수에 액세스할 수 있으므로 스레드 안전성 문제가 제거됩니다.

코드가 더 표현력이 풍부합니다. 여러 단계로 의도를 전달하는 대신(초기 더미 값 만들기, 가격 반복, 변수에 할인된 값 추가 등) 간단히 목록의 맵 메서드에 할인된 값이 있는 다른 목록을 반환하고 합산하도록 요청합니다.

함수형 스타일 버전은 더 간결합니다. 명령형 버전보다 동일한 결과를 얻는 데 필요한 코드 줄이 적습니다. 더 간결한 코드는 작성해야 할 코드, 읽어야 할 코드, 유지 관리해야 할 코드가 적다는 것을 의미합니다. ​간결함이 그저 코드가 적다는 것을 의미 할까요?

> [!NOTE]      
> 간결함은 짧고, 잡음이 없으며, 의도를 효과적으로 전달하기 위해 본질로 축소됩니다. 이점은 광범위합니다.
코드를 쓰는 것은 재료를 함께 던지는 것과 같고, 간결하게 만드는 것은 그것을 소스로 만드는 것과 같습니다. 간결한 코드를 쓰는 데는 종종 더 많은 노력이 필요합니다. 읽을 코드는 적지만 효과적인 코드는 투명합니다. 이해하기 어렵거나 세부 사항을 숨기는 짧은 코드 목록은 간결함 보다는 간결함 입니다 .
간결한 코드는 디자인 민첩성을 높이고 의식이 덜합니다. 즉, 디자인 아이디어를 빠르게 시도해 보고 좋은 경우 진행하거나, 좋지 않은 경우 진행할 수 있습니다.


함수형 스타일 버전은 직관적입니다. 즉, 코드를 문제를 설명하는 방식과 더 비슷하게 읽을 수 있고 구문에 익숙해지면 이해하기가 더 쉽습니다. map 메서드는 주어진 함수(할인을 계산하는 함수)를 컬렉션의 각 요소에 적용하여 다음 그림에서 볼 수 있듯이 결과 컬렉션을 생성합니다.


> 우리는 동료 프로그래머들이 적절한 시기에 데이터베이스 연결을 닫았는지, 필요 이상으로 거래를 유지하지 않는지, 예외를 적절한 수준에서 적절히 처리하고 있는지, 잠금을 적절하게 보호하고 해제하고 있는지 등을 확인해야 합니다. 목록은 계속 늘어갑니다.

- 이러한 각각은 개별적으로 보면 별 문제가 아닌 것처럼 보일 수 있습니다. 하지만 도메인의 고유한 복잡성과 결합하면 상황이 압도적이고 노동 집약적이며 유지하기 어려워집니다.


  > 우리는 객체 목록을 처리하고 세트와 맵을 다루기 위해 항상 반복을 작성합니다. Java에서 익숙한 반복자는 익숙하고 원시적이지만 간단하지 않습니다. 작업하는 데 몇 줄의 코드가 필요할 뿐만 아니라 구성하기도 어렵습니다.
  

- 컬렉션의 각 요소를 반복하고 인쇄하려면 어떻게 해야 할까요? for 루프를 사용할 수 있습니다. 컬렉션에서 일부 요소를 선택하려면 어떻게 해야 할까요? 동일한 for 루프이지만, 일부 추가 가변 변수가 작업을 지원하기 위해 개입해야 합니다. 이제 값을 선택한 후, 최소값, 최대값 또는 평균과 같이 결과를 단일 값으로 줄이려면 어떻게 해야 할까요? 더 많은 루프, 더 많은 가변 변수.

# Enforcing Policies 
Policies rule enterprise applications.
- 예를 들어, 운영에 적절한 보안 자격 증명이 있는지 확인해야 할 수도 있습니다
- 거래가 빠르게 실행되고 감사 추적이 적절하게 업데이트되는지 확인해야 할 수도 있습니다.
```java
Transaction transaction = getFromTransactionFactory();
	//... operation to run within the transaction ...	
	checkProgressAndCommitOrRollbackTransaction();
	UpdateAuditTrail();

```
> 적절한 `try` 와 `finally` 블록을 구현할 수 있지만, `누군가`가 그 코드를 건드릴 때마다 코드가 `손상`되지 않았는지 다시 확인해야 합니다.




```java
	runWithinTransaction((Transaction transaction) -> {
	  //... operation to run within the transaction ...
        
	});
```
> 또는, 우리는 팩토리를 없애고 이 코드를 뒤집어 놓을 수 있습니다. 거래를 수신하는 대신, 처리 코드를 잘 관리되는 함수로 보낼 수 있습니다. 다음과 같이(의사코드로):
 
> 이것은 엄청난 절감 효과가 있는 아주 작은 단계입니다. 상태를 확인하고 감사 추적을 업데이트하는 정책은 runWithinTransaction 메서드 내에서 추상화되고 캡슐화됩니다. 이 메서드에 트랜잭션 컨텍스트에서 실행해야 하는 코드를 보냅니다. 더 이상 단계를 수행하는 것을 잊거나 예외가 잘 처리되는지 걱정할 필요가 없습니다. 정책 시행 기능이 이 모든 것을 처리합니다.